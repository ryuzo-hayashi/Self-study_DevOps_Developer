# Planning to be Agile
## イテレーション計画によるプロジェクト管理

### upfront planning (事前計画) の問題点

プロジェクトの初期段階は、最も情報が少なく、不確実性が高い時期です。にもかかわらず、多くのプロジェクトでこの段階にすべての計画を立ててしまいます。
* **不確実性の高さ:** ソフトウェア開発などの分野では、環境や要件が常に変化します（例：OSのパッチ、パッケージの更新）。初期の予測はすぐに陳腐化します。
* **デッドラインの超過:** 不確実性が高い初期段階で立てた計画は現実と乖離しやすく、結果としてデッドラインを守れなくなります。

---

### イテレーション計画 (Iterative Planning) の利点

イテレーション計画は、**アジャイル**の考え方の中心であり、「未知を航海する」ための効果的な手法です。

* **知識を最大限に活用:** 最も情報が少ない段階で全てを決定するのではなく、分かっている範囲（例：直近2週間）の計画を立てます。
* **軌道修正:** プロジェクトを進める中で新しい情報や状況変化が明らかになったら、その都度計画を調整します。
* **精度の向上:** 遠い未来の予測は不確実性が高いため精度が低いですが（例：3ヶ月先の計画は精度50%）、直近の計画は高い精度で立てることができます（例：2週間先の計画はほぼ100%）。

---

### まとめ

* ** upfront planning (事前計画):** 情報が最も少ない段階で全体の計画を立てるため、デッドライン超過の原因となります。
* **イテレーション計画 (Iterative Planning):** 分かっている範囲で計画を立て、進捗に合わせて計画を調整することで、より正確な見積もりと柔軟なプロジェクト進行が可能になります。

## アジャイル導入の失敗: トレーニングなしでの役割転換

### 役割の違いを理解せずに転換することの危険性

アジャイル開発を導入する際、既存の役割の人員をトレーニングなしで新しい役割に就かせると、失敗する可能性が高いです。これは、アジャイルにおける役割が従来の役割とは根本的に異なるスキルセットとマインドセットを要求するためです。

---

### 主要な役割転換とその課題

アジャイルを導入する際によく見られる、トレーニングなしでの役割転換の例と、それに伴う課題を以下に示します。

#### **1. プロダクトマネージャー → プロダクトオーナー**
* **従来のプロダクトマネージャー:**
  * 職務上の肩書きであり、予算管理や事業運営に焦点を当てることが多い。
* **アジャイルのプロダクトオーナー:**
  * Scrumにおける役割であり、プロダクトのビジョンを持つ「ビジョナリー」として、チームを率いてスプリントゴールを達成するための実験を主導する。
  * 利害関係者（ステークホルダー）とチームの橋渡し役となり、ビジネス要件を技術的な目標に落とし込むことが求められる。

#### **2. プロジェクトマネージャー → スクラムマスター**
* **従来のプロジェクトマネージャー:**
  * タスク管理者であり、計画に沿って全員を動かすことに重点を置く。
  * リスク発生時は、リスクを文書化し、チーム自身に解決策を求めがちです。
* **アジャイルのスクラムマスター:**
  * チームを自律的に機能させるための**コーチ**です。
  * チームメンバーにタスクを割り当てるのではなく、チーム自身がタスクを選択・実行できるように導きます。
  * チームの障害（インピーダンス）が発生した場合は、チームに代わってそれを排除し、チームが中断なく作業に集中できる環境を整えます。

#### **3. 開発チーム → Scrumチーム**
* **従来の開発チーム:**
  * 一般的にソフトウェアエンジニア（開発者）のみで構成されることが多い。
* **アジャイルのScrumチーム:**
  * 開発者だけでなく、テスター、セキュリティ担当者、ビジネスアナリスト、運用担当者など、インクリメント（完成した製品の一部）を構築するために必要な**多機能（クロスファンクショナル）**なメンバーで構成されます。

### 成功のための鍵

アジャイル開発を成功させるためには、役割の再編成と適切なトレーニングが不可欠です。

* **マインドセットの転換:**
  * 従来の**ウォーターフォール**型開発のように、固定された機能、期間、コストでプロジェクトを管理するという考え方を捨てなければなりません。
* **マネジメント層の関与:**
  * 上層部がアジャイルの原則を理解し、チームに対し、長期的な予測ではなく、直近のスプリントでの成果を問うような質問をすることで、アジャイルな文化を根付かせることができます。

## かんばん（Kanban）とアジャイル計画ツール

### 1. かんばん（Kanban）ボードの基本

* **かんばんボードとは:**
  * 実行すべき作業、進行中の作業、完了した作業を視覚的に追跡するためのツールです。
  * 物理的なホワイトボードに付箋を貼るだけでも機能します。
* **構成要素:**
  * **パイプライン（列）:** 「やるべきこと」「進行中」「完了」など、作業の段階を示す列。
  * **ストーリー（カード/付箋）:** 開発すべき機能やタスクを記述したもので、パイプライン間を移動します。
* **ワークフロー:**
  * 新しい作業はボードの左端に追加され、完了するにつれて右へと移動していきます。これにより、プロジェクトの進捗状況が一目で分かります。

---

### 2. ZenHubとGitHubの統合

* **ZenHubの概要:**
  * GitHubのプラグインとして機能するアジャイル計画ツールです。
  * 開発者は使い慣れたGitHubから離れることなく、プロジェクト管理（かんばんボード）を行うことができます。
* **利用の利点:**
  * **一元管理:** GitHubのIssueがそのままZenHubの「ストーリー」として機能するため、開発者は別のツールにステータスを更新する必要がありません。これにより、情報の陳腐化を防ぎ、常に最新の状態を保つことができます。
  * **簡単な進捗確認:** マネージャーやチームメンバーは、ZenHubのボードを見れば、どのタスクが進行中か、誰が担当しているか、どのタスクが完了したかをすぐに把握できます。

---

### 3. ZenHubの主要なパイプライン（列）

ZenHubでは、以下のデフォルトのパイプライン（列）が用意されており、ワークフローを視覚的に追跡します。

| パイプライン名 | 用途 |
| :--- | :--- |
| **New Issues** | 新規に作成されたIssueの「受信トレイ」です。定期的に整理し、適切なパイプラインに移動します。 |
| **Icebox** | 長期的に着手予定のない、**コールドストレージ**です。すぐに取り組む予定のないタスクを保管し、ボードの clutter（乱雑さ）を避けます。 |
| **Product Backlog** | プロダクトで将来的に実施したいすべての作業項目（ストーリー）が格納されます。 |
| **Sprint Backlog** | 次の2週間のスプリントで取り組むと決定された作業項目です。開発者はこのパイプラインに集中して作業します。 |
| **In Progress** | 現在、開発者が作業しているタスクです。担当者のアバターが表示されるため、誰が何に取り組んでいるかが一目で分かります。 |
| **Review QA** | コードが完成し、プルリクエストが作成されたタスクです。他の開発者がレビューを行う段階です。 |
| **Done** | 開発者が作業を完了し、コードがマージされたタスクです。プロダクトオーナーによる承認は含みません。 |


# User Stories
## 良いユーザー物語の作成方法

この講義では、アジャイル開発における「ユーザー物語（User Story）」の書き方と、それがチーム開発においてなぜ重要なのかについて解説しています。ユーザー物語は単なる要件定義ではなく、ビジネス価値を明確にすることで、開発チームとステークホルダー間の共通理解を深めるための重要なツールです。

### ユーザー物語とは

ユーザー物語は、**ビジネス価値**を持つ機能の最小単位を記述したものです。誰が（役割）、何を必要とし（機能）、なぜそれを必要とするのか（価値）を明確にすることで、開発者がその機能の目的を深く理解できるようにします。

* **従来の要件定義との違い:**
    * 従来の要件が「〜が必要」といった機能中心の記述であるのに対し、ユーザー物語は**誰のために、どのような価値をもたらすのか**に焦点を当てています。
* **記述形式:**
    * `As a <役割>` (〜として)
    * `I need <機能>` (〜という機能が必要だ)
    * `so that I can <ビジネス価値>` (〜というビジネス上の利益を得るために)

**例:**
`As a` **マーケティングマネージャー**
`I need` **顧客の名前とEメールのリスト**
`so that I can` **マーケティングキャンペーンの告知を行う**

---

### ユーザー物語の構成要素

良いユーザー物語には、以下の3つの要素が含まれている必要があります。

1.  **詳細な記述:**
    * 上記の記述形式（役割、機能、価値）に加えて、**前提条件**や**補足情報**を記述します。
    * 開発者が設計や実装を行う際に役立つヒント（例：使用するデータベースの種類など）を含めることで、開発プロセスの効率を高めます。
2.  **受け入れ基準（Acceptance Criteria）:**
    * そのユーザー物語が「完了した」と判断するための具体的な条件を定義します。
    * これにより、開発チームとプロダクトオーナー間の認識のズレを防ぎ、手戻りを減らすことができます。
    * **Gherkin構文**（Given-When-Then）がよく使用されます。
        * **Given:** 前提条件（例：データベースに顧客が100人いる）
        * **When:** アクション（例：顧客Eメールリストをリクエストする）
        * **Then:** 期待される結果（例：90人の顧客Eメールリストが表示される）
3.  **INVESTの原則:**
    * ビル・ウェイク氏が提唱した、良いユーザー物語を作成するための6つの原則を表す頭字語です。

| 原則 | 意味 |
| :--- | :--- |
| **I**ndependent | 独立している: 他のユーザー物語に依存しすぎないようにする。 |
| **N**egotiable | 交渉可能である: 詳細が厳密に決まっているのではなく、議論を通じて調整できる。 |
| **V**aluable | 価値がある: ユーザーやビジネスにとって明確な価値がある。 |
| **E**stimable | 見積もり可能である: 開発に必要な工数を見積もることができる。 |
| **S**mall | 小さい: 1つのスプリントで完了できるサイズである。 |
| **T**estable | テスト可能である: 完了したかどうかをテストで検証できる。 |

---

### エピック（Epic）について

**エピック**は、**1つのスプリントでは完了できないほど大きなユーザー物語**を指します。
* **役割:** 大きなアイデアや機能を包括的に捉えるために使用されます。
* **使い方:**
    * 最初は大きなエピックとして定義し、バックログ（開発タスクリスト）の洗練（リファインメント）プロセスで、実行可能な小さな**ユーザー物語**に分割していきます。
    * これにより、開発チームは段階的に作業を進め、価値を継続的に提供できます。
* **階層関係:**
    * エピックはユーザー物語よりも上位の概念であり、複数のユーザー物語から構成されます。
    * ユーザー物語が大きすぎる場合、それをエピックとして扱い、より小さなユーザー物語に分解します。

## ストーリーポイントの効果的な活用

この講義では、アジャイル開発におけるストーリーポイントの定義、割り当て方法、そしてその際の注意点について解説しています。

---

### ストーリーポイントとは

**ストーリーポイント**は、ユーザー物語（User Story）の実装にかかる**相対的な難易度**を測るための抽象的な指標です。
* **時間の見積もりではない:** 作業時間（例：「3時間」「2日」など）を直接的に示すものではありません。これは人間が正確な作業時間を予測するのが苦手であるため、時間換算を避けるための工夫です。
* **考慮すべき要素:**
    * **労力（Effort）:** 作業の物理的な大変さ。
    * **複雑性（Complexity）:** 技術的な難しさや、解決策の複雑さ。
    * **不確実性（Uncertainty）:** 未経験のタスクであるか、未知の要素があるか。

---

### ストーリーポイントの割り当て方法

ストーリーポイントは相対的なサイズとしてチーム全体で合意形成を行います。

1.  **相対評価:**
    * Tシャツのサイズ（S, M, L）のように、他のストーリーと比較して相対的にどのくらいの大きさかを評価します。
    * 例：「このストーリーは『中（M）』サイズだね。じゃあ、このストーリーはそれより少し大きいから『大（L）』かな？」のように、基準となるストーリーをもとに比較します。
2.  **フィボナッチ数列の利用:**
    * 多くのツールでは、**フィボナッチ数列**（1, 2, 3, 5, 8, 13...）をストーリーポイントとして使用します。
    * これは、ストーリーのサイズが大きくなるにつれて見積もりの不確実性が増すため、非線形な評価を可能にするためです。
    * **推奨される使い方:**
        * チームで基準となるストーリー（例：`5`を「中（M）」とする）を1つ決めます。
        * 他のストーリーは、その基準と比較して相対的なポイントを割り当てます。
        * ポイントが大きすぎるストーリー（例：`21`など）は、1つのスプリントで終わらない可能性があるため、複数の小さなユーザー物語に分割することを検討します。

---

### ストーリーポイント利用時の注意点（アンチパターン）

* **ウォールクロックタイム（時間）への換算:**
    * 「1ポイント＝1日」「5ポイント＝5時間」のように、ストーリーポイントと具体的な作業時間を結びつけるのは**最も避けるべきアンチパターン**です。
    * ストーリーポイントはあくまで相対的な難易度を測るためのものであり、時間換算を行うと、本来の目的が失われ、見積もりの正確性も下がります。
* **ストーリーは小さく保つ:**
    * 1つのユーザー物語は、**数日程度**で完了できる程度の小さなサイズに保つのが理想です。
    * 大きすぎるストーリーは、分割して複数のスプリントにわたるエピックとして管理します。

## プロダクトバックログの構築

この講義では、アジャイル開発における**プロダクトバックログ**の定義、構築方法、そして要件をユーザー物語に変換するプロセスについて説明します。

-----

### プロダクトバックログとは

**プロダクトバックログ**は、未実装のユーザー物語（User Story）を**優先順位付けしてまとめたリスト**です。

  * **全ての未実装ストーリー:** まだスプリントに取り掛かっていない、今後取り組む予定の全ての機能やタスクが含まれます。
  * **優先順位付け:**
      * リストの上位にあるストーリーは、ビジネス価値が高いと判断されたものであり、より詳細な情報が必要です。
      * リスト下位のストーリーは、将来的に取り組む可能性のあるもので、詳細は不明瞭なままでも構いません。

-----

### 要件からユーザー物語への変換

顧客から提示された要件（例：「カウンター機能が必要」）を、チームが開発しやすい**ユーザー物語**に変換するプロセスが重要です。

  * **「As a, I need, so that」のテンプレートの活用:**
      * 講義では、ユーザー物語を作成するために、以下のテンプレートを使用することを推奨しています。
      * `As a <役割>` (〜として): 誰がこの機能から利益を得るのかを明確にします。
      * `I need <機能>` (〜という機能が必要だ): ユーザーが何を求めているのかを記述します。
      * `so that I can <ビジネス価値>` (〜というビジネス上の利益を得るために): なぜこの機能が必要なのか、その価値を明確にします。

**例（カウンターサービス構築の要件から変換）：**

| 顧客要件 | 変換されたユーザー物語 |
| :--- | :--- |
| カウンター機能が必要 | **As a user, I need a service that has a counter, so that I can keep track of how many times something has been done.**\<br\>（ユーザーとして、何かが実行された回数を記録できるように、カウンター機能を持つサービスが必要です。） |
| 複数のカウンターが必要 | **As a user, I need to have multiple counters, so that I can keep track of several counts at once.**\<br\>（ユーザーとして、複数のカウントを同時に追跡できるように、複数のカウンターが必要です。） |
| 再起動後もカウンター値を保持する必要がある | **As a service provider, I need a service to persist the last known count, so that users don't lose track of their counts after the service is restarted.**\<br\>（サービスプロバイダーとして、サービス再起動後もユーザーがカウントを失わないように、最後の既知のカウントを保持するサービスが必要です。） |
| カウンターをリセットできる必要がある | **As a system administrator, I need the ability to reset the counter, so that I can redo counting from the start.**\<br\>（システム管理者として、最初からカウントをやり直せるように、カウンターをリセットする機能が必要です。） |

このように要件をユーザー物語に変換することで、誰にとって、なぜその機能が重要なのかという**ビジネス価値**が明確になります。

-----

### プロダクトバックログの組み立て方

変換されたユーザー物語をプロダクトバックログとして整理する手順は以下の通りです。

1.  **新規イシュー（New Issues）:**
      * 顧客からの新しい要件やアイデアを、初期のユーザー物語としてここに格納します。これは、まだ詳細が決まっていない「受信箱」のようなものです。
2.  **プロダクトバックログ:**
      * 新規イシューから、今後開発する可能性のあるストーリーを選び、優先順位をつけて配置します。
      * 優先順位が高いものから順にリストの上部に配置します。
      * **例:** カウンターサービスでは、「カウンター機能」が最も基本となるため、これを最優先とし、次に「再起動後も値を保持する」機能、そして「カウンターのリセット機能」という順序で優先度をつけます。「複数カウンター」機能は後回しにする、といった判断を行います。
3.  **詳細の追加:**
      * 優先順位が高いストーリー（バックログの上部にあるもの）から順に、詳細（受け入れ基準など）を加えて「スプリント準備完了」の状態にしていきます。下位のストーリーは、現時点では詳細がなくても構いません。


# The Planning Process
## スクラムにおけるバックログリファインメント

この講義は、スクラム開発における**バックログリファインメント**のプロセスと具体的な会議の進め方を解説しています。目的は、開発チームがスムーズにスプリントを開始できるよう、**プロダクトバックログ**を「スプリントレディ（Sprint Ready）」な状態にすることです。

### バックログリファインメントの目的

  * **バックログの優先順位付け:** 最も重要な項目をバックログの上位に配置します。
  * **タスクの分解:** 大きすぎるストーリー（タスク）を、1つのスプリントで完了できるサイズに分割します。
  * **詳細の追加:** 開発者がすぐに作業を開始できるよう、ストーリーに十分な詳細情報（要件、受け入れ基準など）を追加します。

### 参加者

  * **プロダクトオーナー:** **必須**。プロダクトのビジョンを持ち、ストーリーを作成し、優先順位を決定する中心人物です。
  * **スクラムマスター:** **必須**。プロダクトオーナーがバックログを整理するのをサポートします。
  * **開発チーム:** **任意**。技術的な質問に答えたり、依存関係を確認したりするために、開発リードやアーキテクトなど1〜2名の参加が推奨されます。全員が参加するのは時間の無駄とされています。

### 会議の具体的な進め方

バックログリファインメントの会議は、以下のステップで進行します。

#### 1\. 新規課題のトリアージ（New Issue Triage）

最初に、カンバンボードの「新規課題（New Issues）」列にあるタスクを整理します。これは「受信箱（Inbox）」を空にする作業であり、会議の最優先事項です。

| 決定事項         | 意味                                     | 移行先            |
| ---------------- | ---------------------------------------- | ----------------- |
| **プロダクトバックログへ移動** | 近い将来、取り組むべき重要なタスク。 | プロダクトバックログ |
| **アイスボックスへ移動** | すぐには取り組まないが、将来的に検討するタスク。 | アイスボックス |
| **却下（Reject）** | プロダクトの方向性とは異なる、今後取り組む予定のないタスク。 | なし（削除）       |

#### 2\. プロダクトバックログの精査

トリアージが完了したら、プロダクトバックログの精査に進みます。

  * **優先順位の調整:** プロダクトオーナーは、ビジネス価値に基づいてタスクの順位を再調整します。

  * **見積もりの付与:** ストーリーポイントなどを用いて、タスクの規模を大まかに見積もります。これはスプリントプランニングでの詳細な見積もりを円滑にするためです。

  * **スプリントレディな状態への更新:** タスクを「スプリントレディ」な状態にするため、以下の情報を追加します。

      * **前提条件（Assumptions）:** 開発を進める上で必要な前提となる事項を明記します。
      * **受け入れ基準（Acceptance Criteria）:** タスクが完了したと判断するための条件を定義します。これは**Gherkin構文**（Given-When-Then）を用いて記述すると、より明確になります。

    **例：**

    ```gherkin
    Given I have incremented the counter to 2
    When I make a call to get the counter
    Then it should return 2 as the counter value
    ```

## バックログリファインメントの実践

この講義は、バックログリファインメント（Backlog Refinement）を効果的に行い、プロダクトバックログのタスクを\*\*「スプリントレディ」**な状態にするための具体的な方法を解説します。特に、タスクの**ラベル付け**と**テクニカルデット\*\*の概念について重点的に説明しています。

### 1\. ラベルの活用による可視化

カンバンボード上のタスクにラベルを付けることで、作業内容を視覚的に把握しやすくなります。

  * **目的:**
      * どの種類の作業（バグ、機能強化、テクニカルデットなど）が多いかを一目で確認する。
      * チーム全体の作業バランスを調整する。
  * **主要なラベルの例:**
      * **Enhancement（機能強化）:** 顧客に直接的な価値を提供する新しい機能や改善。
      * **Bug（バグ）:** 既存の機能の不具合。
      * **Technical Debt（テクニカルデット）:** 顧客が直接的な価値を感じないが、将来的な開発を円滑に進めるために必要な作業。

### 2\. テクニカルデットとは？

**テクニカルデット**とは、開発のスピードを優先した結果、将来的に発生する技術的な負債のことです。顧客は直接的な価値を感じませんが、放置するとシステムの不具合や開発効率の低下につながるため、計画的に解消していく必要があります。

  * **定義:** 顧客が価値として認識しないが、開発上必要な作業。
  * **テクニカルデットの例:**
      * コードのリファクタリング（再構成）。
      * 開発環境やテスト環境の構築・保守。
      * データベースなどの基盤技術の変更。
      * セキュリティパッチの適用や外部ライブラリのアップデート。
  * **重要性:** テクニカルデットは自然に発生するものですが、定期的に解消しないと大きな問題につながります。スプリント計画には、常に一定量のテクニカルデット解消タスクを含めることが推奨されます。

### 3\. ストーリーをスプリントレディにするための詳細化

新規に作成されたストーリーや、詳細が不十分なストーリーは、開発者がすぐに着手できるよう以下の情報を追加します。

  * **前提条件（Assumptions）:** タスク実行にあたっての技術的な方針や前提を明記します。
      * **例:** 「カウンタの永続化にはRedisデータベースを使用する。」
  * **受け入れ基準（Acceptance Criteria）:** タスクが完了したと判断するための、満たすべき具体的な条件を記述します。
      * **例:** Gherkin構文（Given-When-Then）を使用し、「サービスを再起動してもカウンタの値が保持される」といった振る舞いを明確に定義する。
      * **構文の例:**
    <!-- end list -->
    ```gherkin
    Given the counter has advanced to 5
    When I call reset on the service
    Then I should see 0 return from the service
    ```

-----

### 4\. バックログリファインメントの運用上のヒント

  * **開催頻度:** 少なくとも**1スプリントに1回**は実施することが重要です。スプリント開始の前に、次回のスプリント計画に備えて行います。
  * **準備の目標:** 常に**2スプリント分**のストーリーが「スプリントレディ」な状態になるように維持します。これにより、予期せぬ遅延が発生しても、開発チームが作業を継続できます。
  * **効率性:** リファインメント会議でストーリーの詳細をできるだけ詰めておくことで、スプリント計画会議（Sprint Planning Meeting）での詳細な議論やドキュメント作成の時間を大幅に削減できます。

## スプリントプランニング

この講義は、スクラム開発における**スプリントプランニング**の進め方について解説しています。これは、次のスプリントで何を達成するか、そのためにどのタスクに取り組むかを決定する重要な会議です。

### 1. スプリントプランニングの目的と参加者

* **目的:** 次のスプリントで達成する**スプリントゴール**を定義し、プロダクトバックログからスプリントバックログを作成することです。これにより、開発チームはスプリント期間中に集中して作業を進めることができます。
* **参加者:**
    * **プロダクトオーナー:** スプリントの目標を提示し、プロダクトバックログの優先順位について説明します。
    * **スクラムマスター:** 会議が円滑に進むようファシリテーションします。
    * **開発チーム:** スプリントで完了できるタスクを決定し、作業の見積もりを行います。

---

### 2. スプリントゴールの設定

各スプリントには明確な**スプリントゴール**が必要です。これは、開発チームが何のために作業をしているのかを理解し、不要な作業や過剰な実装（オーバーエンジニアリング）を防ぐための指針となります。

* **役割:**
    * **プロダクトオーナー:** スプリントゴールを明確に言語化し、そのゴールを達成するためのプロダクトバックログアイテムを提示します。
    * **開発チーム:** ゴールを常に意識し、タスクの実行中に迷った際の判断基準とします。

---

### 3. スプリントプランニングの進め方

スプリントプランニングは、以下のステップで進められます。

1.  **マイルストーンの作成:** GitHubのマイルストーン機能（またはZenHubのスプリント機能）を使って、スプリントの期間（通常は2週間）と**スプリントゴール**を定義します。
2.  **ストーリーの見積もりと選択:**
    * 開発チームは、プロダクトバックログの最上位にあるストーリーから順に検討します。
    * チームは各ストーリーの規模を**ストーリーポイント**で合意します（例：プランニングポーカー）。
    * 詳細が不十分なストーリーは、開発チームが作業に必要な情報をすべて理解しているかを確認します。
3.  **スプリントバックログの作成:**
    * 開発チームは、プロダクトバックログからストーリーポイントを割り当てたタスクをスプリントバックログに移動します。
    * この作業は、チームの**ベロシティ**に達するまで続けます。

---

### 4. ベロシティ（Velocity）とストーリーポイント

* **ベロシティ:** チームが1つのスプリントで完了できる**ストーリーポイントの合計**です。チームの過去の実績に基づいて算出され、将来のスプリントで達成可能な作業量を予測するために使われます。
* **ベロシティの重要性:**
    * チームがスプリントで**過度なコミットメント**をすることを防ぎます。
    * タスクの見積もり精度やチームの習熟度に応じて変化します。
* **注意点:**
    * **異なるチームのベロシティを比較してはいけません。** ストーリーポイントの定義（「Medium」が何ポイントかなど）はチームごとに異なるため、単純な比較は意味がありません。

### 5. ワークフローのまとめ

スプリントプランニングでは、最終的にカンバンボード上で以下のような状態を目指します。



1.  **プロダクトバックログ:** 優先順位が高い、精査済みのストーリーが並んでいます。
2.  **スプリントバックログ:** プロダクトバックログから移動された、今回のスプリントで取り組むとコミットされたストーリーが並んでいます。これらのストーリーには、ストーリーポイントとラベルが付与されています。
3.  **停止のタイミング:** スプリントバックログのストーリーポイント合計がチームのベロシティに達した時点で、タスクの追加を停止します。


