# Working Devops
## テイラー主義とDevOps：ソフトウェア開発における効率的な働き方

---

### 1. テイラー主義（Taylorism）とは

* **概要**: 20世紀初頭にフレデリック・ウィンズロー・テイラーが提唱した、大規模な工場生産のための管理手法。
* **主な特徴**:
    * **指揮統制（Command-and-Control）**: 上層部のマネージャーが計画を立て、現場の作業者はその指示に従い、単純な作業を機械的にこなす。
    * **サイロ化（Functional Silos）**: 組織を機能ごとに独立した部門（サイロ）に分け、各部門が専門的なタスクに特化する。
    * **作業の分断**: 自動車の組み立てラインのように、一つの製品を完成させるために作業を細分化し、各作業員が特定のタスクのみを担当する。

### 2. テイラー主義がソフトウェア開発に適さない理由

* **性質の違い**:
    * **工場生産**: 自動車のように、**既存の部品**を組み合わせて**大量生産**するモデル。
    * **ソフトウェア開発**: ほとんどの部品が**まだ存在しない**ため、コードを自ら書く必要があり、**一点物の「職人技（craftwork）」**や**「知識労働（knowledge work）」**に近い。
* **非効率性の原因**:
    * **引き継ぎ（Handoffs）**: プロジェクトマネージャー→設計者→開発者→テスター→運用→セキュリティといった部門間の引き継ぎが発生する。
    * **問題点**: 各引き継ぎのタイミングで**認識の齟齬**や**コンテキストの喪失**が起こりやすく、**ボトルネック**や**ミスの原因**となる。

### 3. DevOpsの考え方とメリット

* **目的**: テイラー主義的なサイロをなくし、部門間の連携と協業を促すこと。
* **コアとなる文化**:
    * **アジャイル開発**: **プロセスやツールよりも個人と対話を重視**する考え方。
    * **チームワークとコラボレーション**: 異なる部門の専門家が共通の目標に向かって協力する文化を育む。
* **実践方法**:
    * **小規模なリリースを頻繁に行う**:
        * **目的**: 素早いフィードバックを得るため。
        * **効果**: **リスクを最小化**し、**学びを最大化**する。
    * **徹底した自動化**:
        * **目的**: 素早い対応（DevOps responses）を可能にするため。
        * **文化**: 手動での作業を減らし、自動化を奨励・評価する。

### 4. 結論

ソフトウェア開発では、テイラー主義のような**指揮統制型**のマネジメントや**サイロ化**された働き方は非効率です。代わりに、**DevOpsの文化**を取り入れることで、チーム間のコラボレーションを促進し、迅速なフィードバックループと自動化を通じて、高品質なソフトウェアを効率的に開発することができます。

---

## ソフトウェア開発と土木工学の違い

---

### 1. 土木工学プロジェクトのモデル

* **設計と実行の分離**:
    * **建築家**が設計図を作成し、それを**建設チーム**に引き渡す。
    * 建設チームは設計図通りに建物を建設し、完成後は**保守チーム**に引き渡される。
* **特徴**:
    * **静的**: 一度建てられた建物は基本的に変わらない。
    * **引き継ぎ**: 各工程の担当者（建築家、建設チーム、保守チーム）は、自分の役割が終わると次のプロジェクトに移る。
    * **所有権の喪失**: プロジェクト完了後、開発に携わったチームの所有権意識は薄れる。

### 2. ソフトウェア開発の現状と問題点

* **土木工学モデルの適用**: 多くのソフトウェア開発プロジェクトは、土木工学と同様に、**完了すれば終わり**という考え方で進められている。
    * **引き継ぎ**: 設計者から開発者、そしてテスター、最後に運用チームへと引き継がれる。
    * **チームの解散**: プロジェクト完了後、開発チームは解散し、運用・保守は別のチームに引き継がれる。
* **問題点**: このモデルはソフトウェア開発の特性と合致しない。
    * **所有権の欠如**: プロジェクトメンバーが入れ替わるため、コードに対する深い理解や所有権が失われる。
    * **品質の低下**: 引き継ぎの際にコンテキストが失われ、不具合や非効率性が生じる。

### 3. ソフトウェア開発の特性

* **動的・有機的**:
    * **環境の変化**: アプリケーションそのものが変わらなくても、基盤となるOSやパッケージは**常に更新・パッチ適用**が必要。
    * **機能の追加**: 建物と異なり、ソフトウェアには**継続的に新しい機能が追加**される。
* **開発の継続性**:
    * ソフトウェア開発は「**プロジェクト**」として完了するものではなく、長期にわたって強化される「**製品**」として捉えるべきである。

### 4. DevOpsの解決策

* **安定したチーム**: 開発から運用まで、**同一のチームが継続してソフトウェアの構築と保守**を担当する。
* **エンドツーエンドの所有権**:
    * チームがコードに対する深い理解と**所有権**を持つ。
    * これにより、コードをより良くするためのアイデアが生まれやすくなる。
* **プロジェクト管理からの脱却**: ソフトウェア開発を「プロジェクト」としてではなく、**長期的な「製品開発」**として捉えることが、優れたソフトウェアを生み出す鍵である。

## DevOpsにおける行動変容

---

### 1. 伝統的なOpsとDevOpsの比較

| 項目 | 伝統的なOps | DevOps |
| :--- | :--- | :--- |
| **変更の規模** | 大規模で高リスクなプロジェクト | 小規模で継続的な変更 |
| **インフラ** | 手動で構築・設定され、長期間維持される**特殊なインフラ** | 自動化によって一時的に作成・破棄される**一時的なインフラ** |
| **リスク管理** | 変更ウィンドウ（特定の時間帯）のみでの変更を許可 | プログレッシブアクティベーション（随時変更） |
| **プロセス** | **「一度きりの構築」**（手動、ドキュメント不足） | **「自動化された反復可能な構築」** (Infrastructure as Code) |
| **アーキテクチャ** | ネットワーク設計がアプリケーション設計を規定 | アプリケーション設計がネットワーク設計を規定 |

### 2. DevとOpsの間の「壁」と相互認識

* **Devの目標**: ユーザーのニーズに応える**イノベーション**。
* **Opsの目標**: サービスの**安定性**とデータの安全性を確保すること。
* **対立**: これらの目標は相反するため、両者の間に**「混乱の壁（wall of confusion）」**が生まれる。

| 視点 | Devから見たOps | Opsから見たDev |
| :--- | :--- | :--- |
| **認識** | 変更ウィンドウの間に、コードを理解せずに手動で**「一か八か」**の変更を行う集団。 | 不十分なテストやバックアップ計画のまま変更を行い、運用環境と異なる設定を使うため、運用環境に**「動かないもの」**を押し付けてくる集団。 |
| **結果** | このような相互認識は不信感と無関心を生み出し、非効率な作業環境を作り出す。 |

### 3. DevOpsに求められる行動

DevOpsを実現するためには、以下の行動変容が不可欠です。

* **サイロの解体と共同所有**: 組織間の壁や引き継ぎをなくし、**「共有された責任と高い協調性」**の文化を築く。全員が**共通の目標**に向かって協力する意識を持つ。
* **変化を恐れず受け入れる**: 大規模な変更への恐怖を捨て、**小規模な変更**を頻繁に行うことでリスクを管理する。
* **「使い捨て」のインフラ**: **「一度限りの手作りサーバー」**（スノーフレークサーバー）ではなく、**Infrastructure as Code**を用いて、何度でも同じ環境を自動で構築・破棄できる**一時的なインフラ**に移行する。
* **手動から自動へ**: 手作業（チケットキュー）から、自動化された**セルフサービス**への移行を進める。これにより、迅速な対応が可能になる。
* **アラームからデータ駆動のフィードバックへ**: アラームやエスカレーションに頼るのではなく、**データに基づいた迅速なフィードバックループ**を構築し、問題に即座に対応できる体制を整える。

## IaC (Infrastructure as Code) の復習ノート

---

### IaC (Infrastructure as Code) の基本概念

* **定義**: インフラストラクチャをテキスト形式の**実行可能なコード**として記述する手法。
    * 手動での設定変更は再現性が低く、エラーの原因となるため避けるべき。
* **目的**: テンプレートやスクリプトを用いて、システム、デバイス、ソフトウェア、ユーザーなどの設定を自動化し、再現可能なインフラを構築すること。
* **メリット**:
    * コードをバージョン管理システムで管理することで、変更履歴を追跡し、最新の状態を共有できる。
    * **サーバー・ドリフト** (時間とともにサーバーの設定が元の状態からずれていく現象) を防ぎ、障害の原因を排除する。
* **ツール**: Ansible, Puppet, Chef, Docker, Vagrant, Terraform, Kubernetes など。

### エフェメラル・インフラストラクチャ (Ephemeral Infrastructure)

* **概念**: 必要に応じて作成し、不要になったら破棄する、**一時的**で使い捨てのインフラ。
* **考え方**:
    * 「**サーバーはペットではなく家畜** (Servers are cattle, not pets)」という考え方に基づいている。
    * 手作業で個別に設定・修正する「ペット」のように扱うのではなく、問題が発生した際にすぐに交換できる「家畜」のように扱う。
* **メリット**:
    * IaCを使用することで、環境構築が数週間から数分に短縮され、テスト環境などを一時的に作成・破棄することが可能になる。
    * 本番環境と同一のインフラを並行して構築し、新しいアプリケーションをデプロイして動作確認後、切り替えるといった柔軟な運用が可能になる。

### イミュータブル・デリバリー (Immutable Delivery) とコンテナ

* **定義**: 実行中のインフラストラクチャやコンテナに変更を加えないデリバリー手法。
* **Docker の活用**:
    * **Dockerfile**というコードでイメージの構築方法を定義する。
    * このイメージから**コンテナ**が作成される。イメージは常に同じ方法で構築され、コンテナも常に同じ方法でデプロイされる。
    * これにより、開発環境と本番環境の**差異 (parity)** がなくなり、依存関係の問題をなくすことができる。
* **変更方法**:
    * 実行中のコンテナにパッチを当てたり、設定を変更したりすることは**絶対にしない**。
    * 変更を加える場合は、コンテナの元となる**イメージ**を変更し、新しいイメージから新しいコンテナを再デプロイする。
    * 問題が発生したコンテナはすぐに破棄し、新しいコンテナに置き換える。
* **メリット**:
    * ローリングアップデートや即時ロールバックが容易になり、数秒で旧バージョンに戻せる。
    * コンテナに問題が発生した場合でも、新しいコンテナに置き換えるだけで元の状態に戻すことができるため、障害対応が迅速になる。

## 継続的インテグレーション（CI）と継続的デリバリー（CD）

---

### CI と CD の違い

* **継続的インテグレーション (CI)**: 開発者が行った変更を、**ビルド**、**テスト**、**統合**を繰り返しながら、継続的に**マスターブランチ**に統合していくプロセス。テストに合格したコードは、いつでもデプロイ可能な状態になることが目的。
* **継続的デリバリー (CD)**: CI の後に続く実践で、コードを本番環境と**同じような環境**（開発、テスト、ステージングなど）に迅速かつ安全にデプロイできるようにする。
* **注意点**: CI/CDと一括りにされがちだが、これらは別々のプロセス。本番環境へ自動でデプロイする場合を「**継続的デプロイメント**」と呼ぶこともある。

---

### CI における「小さなバッチ」の重要性

* **短い開発サイクル**: 開発者は、長期間にわたるブランチ開発ではなく、**短命なフィーチャーブランチ**で作業し、機能が完成次第、頻繁に（理想的には毎日）マスターブランチに統合する。
* **コンフリクトの低減**:
    * 定期的にコードをコミットすることで、他の開発者との**変更の競合**（コンフリクト）の数を減らせる。
    * 長時間にわたる開発では、変更が蓄積され、マージ時のコンフリクトが解決困難になるリスクが高まる。
* **コードレビューの促進**: プルリクエスト（PR）を活用することで、チームメンバーが互いのコードをレビューする機会が生まれる。これにより、コードの品質が向上し、問題が起こるリスクを低減できる。

---

### CI の自動化とメリット

* **自動化されたビルドとテスト**:
    * プルリクエストが作成されるたびに、CIツール（例：Travis CI, Circle CI, Jenkins, GitHub Actions）が自動でビルドとテストを実行する。
    * **失敗したテストのあるプルリクエストは絶対にマージしない**。
    * テストは自動化されているため、手動でテストする時間を費やすことなく、新機能の開発に集中できる。
* **主なメリット**:
    1.  **迅速な対応**: 自動テストにより、変更に対するフィードバックが速くなる。
    2.  **開発速度の向上**: テストが自動化されているため、常に正常に動作することが保証され、より速く開発を進められる。
    3.  **リスクの低減**: 小さな変更を頻繁に統合することで、コード統合時のリスクが減る。
    4.  **コード品質の向上**: プルリクエストでのレビューにより、コードの品質が向上する。
    5.  **信頼性の高いマスターブランチ**: マスターブランチは常にビルド可能であり、いつでもデプロイ可能な状態が保たれる。**テストされていないコードをマージしてはならない**。

## 継続的デリバリー（CD）とそのリスク管理

---

### 継続的デリバリー（CD）とは

**継続的デリバリー**とは、ソフトウェアをいつでも本番環境にリリースできる状態にするための開発手法です。これは、マスターブランチのコードが常にデプロイ可能であることを意味します。

* **CI/CDパイプライン**: 継続的デリバリーを実現するための自動化された一連のツールチェーンです。コードリポジトリから始まり、ビルド、テスト、品質チェック、セキュリティスキャンなどを経て、最終的にデプロイメント環境に自動で送り出されます。
    * **CI（継続的インテグレーション）** のフェーズ: 計画、コーディング、ビルド、テスト
    * **CD（継続的デリバリー）** のフェーズ: リリース、デプロイ、運用

---

### 継続的デリバリーの5つの原則

1.  **品質の組み込み**: CI/CDパイプラインによる厳格な自動チェックを通じて、常に高いコード品質を維持します。
2.  **小さなバッチでの作業**: 小さな変更の方がテストが容易で、問題が発生するリスクが低いため、頻繁にコミットと統合を行います。
3.  **反復作業の自動化**: コンピュータは反復作業が得意なため、定型的なタスクは自動化し、人間は問題解決に集中します。
4.  **継続的な改善**: 測定可能な指標を用いて常に改善点を追求し、行動に移します。
5.  **全員の責任**: ビルドが壊れた場合、それはチーム全員の責任であり、協力して迅速に修正します。

---

### 継続的デプロイメント（Continuous Deployment）

**継続的デプロイメント**は、継続的デリバリーの一形態で、自動化されたプロセスによってコードを**本番環境**に自動的にデプロイすることを指します。継続的デリバリーが「いつでもデプロイできる状態」を目指すのに対し、継続的デプロイメントは「常に本番にデプロイする」までを自動化します。

---

### DevOpsによるリスク管理

DevOpsでは、リスクを避けるのではなく、**変更の頻度を増やす**ことで管理します。これは一見非直感的ですが、以下の方法で行われます。

1.  **デプロイメントの早期・頻繁な実施**:
    * コードを本番環境にデプロイする前に、開発、テスト、ステージングなど複数の環境に**自動**で何度もデプロイします。
    * これにより、本番デプロイ時には高い確実性で動作することが保証されます。

2.  **デプロイメントとアクティベーションの分離**:
    * **フィーチャーフラグ**と呼ばれる仕組みを使って、コードのデプロイと機能を有効化するタイミングを分離します。
    * これにより、新機能をデプロイした後でも、問題があればすぐに機能をオフにできます。
    * **カナリアテスト**や**ブルーグリーンデプロイメント**といった手法もこれに含まれ、新しいバージョンに少しずつトラフィックを流し、安全性を確認しながら段階的に展開できます。これにより、**ダウンタイムゼロ**でのデプロイメントが可能になります。

## Knight Capitalの事例

---

### 事件の概要

2012年8月1日、金融サービス企業である**Knight Capital**は、旧式のSMARSコードを新しいRLPコードに置き換える作業を行いました。彼らは、古いコードをサーバーに残したまま、オン・オフを切り替えるフラグを再利用する戦略をとりました。

* **人為的なミス**: 8台のサーバーのうち、システム管理者が7台のみを手動でアップグレードし、**1台のサーバー**をアップグレードし忘れてしまいました。
* **悲劇的な結果**: テスト環境だと思ってフラグを切り替えたところ、アップグレードされていない8台目のサーバーが古いコードを実行し、**本物の市場で実際の取引**を開始しました。
* **損害**: わずか45分の間に、数百万件の子注文が送信され、3億9700万株を超える取引が400万件以上実行されました。これにより、同社は**6億4,000万ドル（約640億円）の損失**を出し、翌日には**事業破綻**に追い込まれました。

---

### この種の事故を回避するために取るべきだった対策

Knight Capitalの事例は、**手動でのデプロイメント**がいかに危険であるかを如実に示しています。この種の事故を回避するためには、以下の対策が考えられます。

* **継続的デリバリー（CD）の導入**:
    * **デプロイメントの自動化**: 手動によるサーバー設定は、1台1台異なる設定になるリスクがあります。CDの自動化されたデプロイメントプロセスは、すべてのサーバーが常に**同じ設定**であることを保証します。
    * **CI/CDパイプラインの活用**: テスト環境やステージング環境、本番環境にデプロイする前に、自動化されたテストを実施することで、コードの変更が予期せぬ不具合を引き起こさないことを確実にします。
    * この事例では、もし自動デプロイメントツールを使用していれば、8台のサーバーすべてが同じ新しいコードで構成され、このような設定の不一致は発生しなかったでしょう。

* **デプロイメント環境の統一**:
    * 本番環境とテスト環境が**完全に同一**である「本番環境に類似した環境（production-like environment）」でテストを行うべきでした。
    * これにより、フラグを切り替えた際に、どの環境で何が実行されるかを正確に把握できたはずです。

この事件は、自動化を怠り、**人為的なミス**に依存することが、どれほど大きなリスクとなり得るかを物語る、象徴的な事例です。