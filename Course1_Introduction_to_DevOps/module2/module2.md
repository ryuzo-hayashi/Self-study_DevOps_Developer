# Thinking of DevOps
## Social Coding Principles

---

### Social Codingとは？

**ソーシャルコーディング**は、オープンソースの考え方を企業内の開発に持ち込んだものです。従来のプライベートリポジトリで特定メンバーのみが開発する形式とは異なり、リポジトリを公開し、誰もがコードの再利用や貢献を奨励される開発手法です。

* **課題**:
    * 従来のプライベートな開発では、他チームが既に開発したコードの存在を知ることができず、**車輪の再発明**が頻繁に起こる。
    * 他チームのコードを利用したい場合でも、必要な機能追加を依頼すると、優先度が低かったり、資金が打ち切られたりするリスクがある。結果として、ゼロから作り直すことが多い。
* **解決策**:
    * リポジトリを公開し、他チームが自由にコードをフォーク（分岐）して利用できるようにする。
    * 必要な機能がある場合、リポジトリのオーナーと相談し、**自身で機能を追加してプルリクエストを送る**。
    * これにより、機能追加を依頼するリスクを回避でき、コードの再利用が促進される。
* **仕組み**:
    1.  リポジトリのオーナーと新機能について話し合い、開発の合意を得る。
    2.  GitHub Issueを開き、担当を自分に割り当てる。
    3.  リポジトリを**フォーク**し、新しい**ブランチ**を作成して変更を加える。
    4.  開発が完了したら、**プルリクエスト**を送信してレビューを依頼する。
    5.  リポジトリのオーナーは、コードレビューを行い、必要に応じて修正を要求し、問題なければ**マージ**する。
* **メリット**:
    * **Win-Win**: コード利用者は必要な機能を得られ、コード提供者は無料で機能が追加される。
    * **コスト削減**: コードの再利用により、企業全体の開発コストを削減できる。
    * **オーナーシップ**: リポジトリのオーナーは、プルリクエストの承認権限を持つため、プロジェクトの完全なコントロールを維持できる。

### ペアプログラミングとは？

**ペアプログラミング**は、2人のプログラマーが1つのワークステーションを共有して行う開発手法です。

* **役割**:
    * **ドライバー**: キーボードを操作して実際にコードを書く担当。
    * **ナビゲーター**: 全体像に焦点を当て、ドライバーの作業をレビューしたり、次に何をすべきかを考えたりする担当。
* **流れ**: 約20分ごとに役割を交代することで、両者がそれぞれの役割を経験する。
* **メリット**:
    * **高いコード品質**:
        * 「声に出してプログラミングする」ことで、コードの意図が明確になり、バグが早期に発見される。
        * 不具合は発見が遅れるほど修正コストが増大するため、早期発見は長期的なコスト削減につながる。
    * **スキル共有と成長**:
        * 2人のプログラマーが異なるアプローチを共有することで、互いに学び、**より良いプログラマー**になる。
        * 特にジュニアプログラマーとシニアプログラマーのペアリングは効果的。
    * **コードの理解度向上**:
        * すべてのコードに2人の目が通るため、特定の担当者しか理解できない「属人化」を防ぐ。
        * チーム全体のコードベースに対する理解度が深まり、メンテナンスや機能拡張が容易になる。

## Gitリポジトリとワークフローのガイドライン

---

### Git Feature Branch Workflow

**Git Feature Branch Workflow**は、ソーシャルコーディングをサポートする開発ワークフローです。このワークフローは、各コンポーネントを独立したリポジトリで管理し、短い期間で運用されるフィーチャーブランチとプルリクエストを活用することで、コードの品質向上とチーム内での知識共有を促進します。

* **リポジトリの原則**:
    * **1つのコンポーネントにつき1つのリポジトリ**を作成する。
    * 複数のコンポーネントを1つのリポジトリにまとめる**モノレポは推奨されない**。これは、不必要なコードをチェックアウトする手間を省き、関心のあるコードに集中するためです。
* **ブランチの運用**:
    * **各イシュー（課題）ごとに新しいブランチを作成する**。
    * 長期間存続するブランチ（例: `development`ブランチ）は作らない。
    * 作業が完了したフィーチャーブランチは**すぐに削除する**。ブランチは軽量なため、頻繁に作成・削除することが推奨される。
* **プルリクエストの活用**:
    * `master`ブランチへのコードのマージは、**必ずプルリクエストを介して行う**。
    * プルリクエストは、他の開発者がコードをレビューする機会を提供する。
    * **自分のプルリクエストを自分でマージしてはならない**。常に別のチームメンバーにレビューとマージを依頼することで、すべてのコードに複数の目を通すことが保証される。これは、**コードレビュー**の機会となり、コード品質の向上につながる。

### ワークフローの手順

Git Feature Branch Workflowは以下の流れで実行されます。

1.  **リポジトリの作成/フォーク**: 新しいコンポーネントのためにリポジトリを作成するか、既存のリポジトリをフォークする。
2.  **クローン**: リモートリポジトリをローカル環境にクローンする。
3.  **ブランチの作成**: 作業するイシューに関連する**フィーチャーブランチ**を作成する。
4.  **コードのプッシュ**: 作業が完了したら、ローカルブランチの変更をリモートのフィーチャーブランチにプッシュする。
5.  **プルリクエストの作成**: リモートブランチから`master`ブランチへのマージを要求するプルリクエストを作成する。
6.  **レビューとマージ**: 他のメンバーがプルリクエストのコードをレビューし、承認されれば`master`ブランチにマージされる。

## 少量のバッチでの作業

-----

### 少量のバッチで作業する利点

\*\*少量のバッチ（small batches）\*\*での作業とは、リーン生産方式から派生した概念で、開発を小さく区切り、頻繁に完了させる手法です。これにより、開発の早い段階でフィードバックを得ることが可能になります。

  * **迅速なフィードバック**: 開発した内容が顧客のニーズに合っているかを短時間で確認できます。これにより、仮説が正しいかどうかを素早く検証できます。
  * **無駄の最小化**: もし仮説が間違っていたり、顧客が望まない機能だったりした場合でも、開発に費やす時間やリソースの無駄を最小限に抑えられます。大規模なバッチで数ヶ月かけて開発した後で間違いに気づくといった事態を防ぎます。
  * **実験の促進**: 小さな単位で作業することで、より多くの実験が可能になり、迅速に知見を得ることができます。
  * **DevOpsとの連携**: 少量のバッチでの作業は、\*\*継続的インテグレーション（CI）**や**継続的デリバリー（CD）\*\*といったDevOpsのプラクティスを効果的に実装する上で不可欠です。

-----

### 少量のバッチ vs. 大量のバッチ

手紙を郵送する例で、大量のバッチと少量のバッチでの作業を比較します。この例では、以下の4つの工程を想定します。

1.  パンフレットを折る
2.  封筒に入れる
3.  封をする
4.  切手を貼る

| | **大量のバッチ (50枚ずつ)** | **少量のバッチ (1枚ずつ)**|
|---|---|---|
| **工程の進め方** | 50枚のパンフレットを全て折り終えてから、次の工程（封入）に進む。 | 1枚のパンフレットを折り、封入し、封をし、切手を貼り終えてから、次の1枚に取り掛かる。|
| **最初の完成品までの時間** | 約16分 | 約24秒 |
| **フィードバックまでの時間** | 約11分（封筒の不備）\<br\>約16分（パンフレットの誤字）| 約18秒（封筒の不備）\<br\>約24秒（パンフレットの誤字）|
| **結論** | 最初の完成品ができるまでに時間がかかるため、問題が起きた場合の発見が遅れる。手戻りが発生すると、それまでの作業が無駄になる。 | \*\*シングルピースフロー（Single Piece Flow）\*\*と呼ばれるこの手法では、1つ作業が完了するごとにフィードバックが得られるため、問題に素早く気づくことができ、手戻りを最小限に抑えられる。 |

### バッチのサイズの判断基準

バッチが十分に小さいかどうかは、以下の観点から判断します。

  * **ストーリーのサイズ**: バックログにあるアプリケーション機能（ストーリー）が、頻繁なリリースをサポートするくらい小さく分割されているか。
  * **リリースの頻度**: 機能が大きすぎるためにリリースが遅延していないか。
  * **スプリントの期間**: 機能が1つのスプリントで完了できるサイズか。理想的には、**1週間以内**に完了できるサイズが望ましい。

-----

### 小さなバッチでの作業を可能にする考え方

多くの人は「完成した目標」だけが出荷する価値のあるものだと考えがちです。しかし、少量のバッチでの作業では、最終目標の一部を\*\*「有用なサブセット」\*\*として捉え、それをインクリメンタル（段階的）に提供することで、フィードバックを得ながら最終目標に向かうことが重要です。


## MVP (Minimum Viable Product)の要点ノート

### MVPとは何か？

**MVP（Minimum Viable Product）**とは、最小限の機能でユーザーに価値を届け、仮説を検証するための製品です。

* **目的:** 開発の初期段階で顧客のフィードバックを得て、本当に求められているものを学習し、理解することにあります。
* **誤解:** プロジェクトの「フェーズ1」や「最初のベータ版」とは異なります。それはあくまで「納品」に焦点を当てたものであり、学習を目的としたものではありません。

### 納品志向と学習志向の違い

MVPの真価は、単なる機能の納品ではなく、**学習（Learning）**に重きを置いている点にあります。

* **納品志向の例（NG）:**
    * 顧客から「赤い車」が欲しいと依頼された場合、車の一部である「タイヤ」を納品する。
    * ユーザーは個々のパーツでは何もできず、フィードバックも得られない。
    * 結果として、開発チームは顧客が本当に何を求めているかを最後まで理解できず、当初の計画通りの製品を納品するだけになる。
    * これは、単に製品を細かく分割して段階的に開発しているだけであり、MVPの本質とは異なります。

* **学習志向の例（OK）:**
    * 顧客から「赤い車」が欲しいと依頼された場合、まず「赤いスケートボード」を納品する。
    * これにより、顧客は「赤色」に関するフィードバックを提供でき、「もっと速く走りたい」「風を感じたい」といった、潜在的なニーズが引き出される。
    * 開発チームは、このフィードバックを基に、スケートボードからキックボード、そしてオートバイへと製品を改善していく。
    * 最終的に顧客は、当初求めていた「赤い車」とは異なる「赤いオープンカー」にたどり着くかもしれない。これは、対話を通じて顧客の真の欲求が明らかになった結果です。

| | **納品志向** | **学習志向（MVP）** |
| :--- | :--- | :--- |
| **目標** | 計画通りに製品を完成させること | 顧客から学び、仮説を検証すること |
| **納品物** | 車のパーツ（タイヤ、シャーシなど） | 独立して価値を持つもの（スケートボード、キックボードなど） |
| **顧客の反応** | 個々のパーツでは何もできない | 機能の一部にフィードバックを提供できる |
| **最終結果** | 計画通りの製品 | 顧客が本当に欲しかった製品 |

### MVPサイクルの進め方

1.  **仮説を立てる:** 「顧客は赤い車を欲しがっている」といった仮説を立てます。
2.  **MVPを作成する:** その仮説を検証するための最小限の製品（赤いスケートボード）を作ります。
3.  **フィードバックを得る:** 顧客に製品を使ってもらい、フィードバックを集めます。
4.  **学習する:** フィードバックから、「顧客は速く移動したい」という新たなニーズを発見します。
5.  **次に進む:** 得られた学習を基に、次のMVP（キックボード、オートバイなど）を開発します。
6.  **ピボット or パーシビア:** 各MVPの終了時に、方向転換（**Pivot**）するか、そのまま継続する（**Persevere**）かを判断します。

**失敗を恐れないこと**が重要です。MVPは実験であり、失敗からこそ多くの学びが得られます。その学びが、次のより良い製品へと繋がります。

---

## テスト駆動開発（TDD）の要点ノート

### 1. テスト駆動開発（TDD）とは
**テスト駆動開発（TDD）**は、コードを書く前に**テストケースを先に書く**開発手法です。これは、コードがどのような振る舞いをすべきかを先に定義することで、その目的に焦点を当てて開発を進めることができます。

* **開発の視点**: TDDは、コードの利用者（クライアント）の視点に立って、**「どのようにコードを呼び出したいか」**を先に考えることを促します。これにより、利用しやすい高品質なAPIやコードを設計できます。
* **開発者の言い訳への反論**:
    * 「コードが動くのは分かっている」→ 将来の自分や他の開発者が変更を加えた際に、予期せぬバグがないか確認するための**ベースライン**となります。
    * 「バグのあるコードは書かない」→ 外部ライブラリのバージョンアップなど、**環境の変化**によってコードが動かなくなるリスクに対応できます。
    * 「時間がない」→ テストケースを先に書くことは、後の**デバッグにかかる時間を大幅に削減**し、結果的に開発全体の時間を短縮します。

### 2. TDDのワークフロー「レッド、グリーン、リファクタリング」

TDDは、**レッド、グリーン、リファクタリング**と呼ばれる以下の3つのステップを繰り返すことで、コードの品質を高めていきます。

1.  **レッド（Red）**: 意図するコードの振る舞いを定義する**失敗するテストケース**を作成します。まだコードは存在しないため、テストは必ず失敗します。
2.  **グリーン（Green）**: テストを通過させるために、**必要最小限のコード**を実装します。この段階では、コードの完璧さや綺麗さは求められません。
3.  **リファクタリング（Refactor）**: テストがすべて通る状態を保ちながら、コードをより良く、より分かりやすく、より効率的に改善します。

この繰り返しにより、機能追加と品質向上が同時に行われます。多くのテストツールがこの失敗（赤）と成功（緑）の色で結果を表示することから、この名前がつけられました。

### 3. DevOpsにおけるTDDの重要性

TDDは、DevOps（開発と運用が一体となった文化）の実現に不可欠です。

* **開発時間の短縮**: テストケースがコードの変更による影響をすぐに教えてくれるため、安心して素早くコーディングやリファクタリングを進められます。
* **コードの信頼性向上**: コードの動作が期待通りであることを保証し、将来的な変更が既存の機能を壊すことを防ぎます。
* **CI/CDパイプラインの基盤**: **継続的インテグレーション（CI）**や**継続的デリバリー（CD）**を自動化するためには、テストも自動化されていることが前提となります。TDDによって書かれた自動テストは、バグが本番環境にデプロイされるのを防ぐための重要な役割を果たします。自動化されたテストなしには、CI/CDパイプラインを構築することはできません。

## 行動駆動開発（BDD）の要点ノート

### 1. 行動駆動開発（BDD）とは
**行動駆動開発（BDD：Behavior Driven Development）**は、システムの**外部から見た振る舞い**に焦点を当てた開発手法です。これは、各コンポーネントの内部的な動作に焦点を当てる**テスト駆動開発（TDD）**とは対照的です。BDDは、システムがビジネス成果に最も直接的に貢献する振る舞いのみを実装することを促し、**「正しいものを構築しているか？」**という視点を重視します。

| 開発手法 | 焦点 | 視点 |
|:---:|:---:|:---:|
| **BDD** | システムの振る舞い（外部から） | 利用者の視点 |
| **TDD** | 個々のコンポーネントの機能（内部から） | 開発者の視点 |

---

### 2. BDDのワークフローとGherkin言語

BDDのワークフローでは、まず開発者、テスター、顧客が協力して、システムの振る舞いを記述した**具体的な例**を作成します。この振る舞いは、**Gherkin**と呼ばれる自然言語に近い構文で記述されます。Gherkinは、誰にでも理解しやすいシンプルな構文であるため、チーム全体のコミュニケーションを円滑にします。

* **Gherkin構文**:
    * `Given`（〜という状況で）: テストの前提条件を設定し、システムを既知の状態にします。
    * `When`（〜というイベントが起こったら）: システムに対する主要なアクションや操作を記述します。
    * `Then`（〜という結果になるはずだ）: アクションの結果として期待される、検証可能な振る舞いを記述します。
    * `And`（そして）: 各ステップに続きの条件を追加する場合に使用します。

* **Gherkinの例**:
    `Feature: 返品処理`
    `Scenario: 返金されたアイテムが在庫に戻される`
    `Given 顧客が以前に黒いセーターを購入した`
    `And 在庫には黒いセーターが3つある`
    `When 顧客がそのセーターを返品し返金を要求する`
    `Then 在庫の黒いセーターは4つになるはずだ`

---

### 3. BDDの主な利点

BDDは、開発プロセス全体にわたって多くのメリットをもたらします。

* **コミュニケーションの改善**: 開発者、テスター、プロダクトオーナー、顧客など、すべての関係者が共通の構文でシステムの振る舞いを理解できるため、チーム内のコミュニケーションが向上します。
* **明確な要件定義**: Gherkin構文で記述された振る舞いの定義は、ユーザー要件（User Story）の**受け入れ基準（Acceptance Criteria）**となります。これにより、「完了」の定義が明確になり、認識のズレを防ぎます。
* **ドキュメントとテストの統合**: Gherkinで記述されたドキュメント（Featureファイル）は、それ自体が**仕様書**であり、かつ**自動化された受け入れテスト**として実行可能です。これにより、仕様とテストの間に齟齬が生まれることがなくなります。
* **高品質なコードとコスト削減**: 振る舞いが明確に定義されていることで、より高品質なコードが生まれ、将来的なメンテナンスコストやバグ発生のリスクを低減します。
* **テストプロセスの早期化**: 開発が始まる前にテストシナリオが作成されるため、テストの自動化プロセスをより早く開始できます。

## クラウドネイティブ・マイクロサービス

### 1. クラウドネイティブ・マイクロサービスとは
クラウドネイティブ・マイクロサービスは、クラウドの利点を最大限に活用するために設計されたアプリケーションの設計思想です。

* **定義**: 1つのアプリケーションを、**独立した小さなサービス**の集合体として開発するアーキテクチャスタイルです。
* **特徴**:
    * **独立性**: 各サービスは他のサービスから独立して機能し、それぞれが特定の**ビジネスドメイン**（例：配車サービスの「ドライバー」「決済」など）に特化しています。
    * **通信**: サービス間の通信は、主に**REST API**などの軽量なメカニズムを通じて行われます。これにより、サービス間の依存関係を疎に保ちます。
    * **ステートレス**: 各サービス自体は状態を持たず、状態（データ）は専用のデータベースに永続化されます。これにより、サービスの柔軟なスケーリングと回復力が向上します。

### 2. モノリシックとマイクロサービスの違い

従来の**モノリシック（Monolithic）**アーキテクチャとマイクロサービスアーキテクチャでは、アプリケーションの構造と運用方法が根本的に異なります。

| 特徴 | モノリシック・アーキテクチャ | マイクロサービス・アーキテクチャ |
|:---:|:---:|:---:|
| **構造** | すべての機能が単一の巨大なアプリケーションとして構築される | 複数の小さな独立したサービスで構成される |
| **デプロイ** | アプリケーション全体をまとめてデプロイする必要がある | 各サービスを個別にデプロイ可能 |
| **スケーリング** | 全体のキャパシティを増やすためにアプリケーション全体をスケールする必要がある | 必要なサービスのみを個別にスケール可能 |
| **データベース** | 複数のコンポーネントが単一のデータベースを共有する | 各サービスが自身のデータベースを管理する |
| **開発** | 他のチームと密に連携・調整する必要がある（特にDBのスキーマ変更時） | サービス間のAPIを介した疎結合により、他のチームとの調整が少なくて済む |

### 3. クラウドネイティブ・マイクロサービスのメリット

このアーキテクチャは、クラウドプラットフォームの特性を活かし、DevOpsの実現を強力にサポートします。

* **水平スケーリング**: 特定のサービスの負荷が増加した場合、そのサービスだけを独立してスケールアップ（増やす）ことができます。これは「**インスタンスは家畜（cattle）であり、ペット（pets）ではない**」という考え方に基づき、障害が発生したインスタンスを修復するのではなく、破棄して新しいインスタンスに置き換えるアプローチをとります。
* **独立したデプロイメント**: 各サービスが独立しているため、あるサービスの変更やアップグレードが他のサービスに影響を与えることなく、迅速かつ安全にデプロイできます。
* **技術選択の自由**: 各サービスが独立したデータベースを持つため、サービスごとに最適なデータベース（SQL、NoSQLなど）を選択できます。
* **DevOpsとの相性**: 各サービスが小さく独立しているため、継続的デリバリー（CD）などのDevOpsパイプラインとの相性が非常に良く、迅速な開発とデプロイを可能にします。

## 障害に備えた設計（Designing for Failure）の要点ノート

### 1. 障害に備えるという考え方

クラウドネイティブなマイクロサービスアーキテクチャでは、多数のサービスが連携するため、**障害は避けられないもの**と考える必要があります。重要なのは、**障害をいかに早く検知し、迅速に回復するか**に焦点を移すことです。これにより、アプリケーションはより堅牢（レジリエント）になります。

* **開発の役割**: 障害への備えは、もはや運用チームだけの問題ではなく、**開発段階から回復力を組み込む**必要があります。
* **指標の変化**: DevOpsでは、「故障までの平均時間（MTTF）」から「**回復までの平均時間（MTTR）**」へと、重要な指標が変化しています。

---

### 2. アプリケーションを回復可能にするための設計パターン

アプリケーションを障害に強くするために、以下の主要な設計パターンが利用されます。

* **リトライパターン（Retry Pattern）**:
    * **概要**: ネットワークの一時的な問題など、**一時的な障害**に対応するためのパターンです。
    * **仕組み**: サービスへの接続が失敗した場合、すぐにエラーを返すのではなく、**指数関数的に待機時間を長くしながら**再試行します。これにより、バックエンドサービスが回復する時間を与え、システム全体を過負荷にすることなく、正常な接続を試みます。

* **サーキットブレーカーパターン（Circuit Breaker Pattern）**:
    * **概要**: 依存するサービスが利用できない場合に、**障害が連鎖的に広がる（カスケード障害）のを防ぐ**ためのパターンです。
    * **仕組み**:
        1.  **Closed（閉状態）**: 通常の状態。サービスへのリクエストを許可します。
        2.  **Open（開状態）**: 失敗が一定のしきい値を超えると、サーキットブレーカーが「開」の状態になります。この状態では、サービスへのリクエストは行われず、すぐにエラーを返します。
        3.  **Half-Open（半開状態）**: 一定時間経過後、状態が半開になり、限定的にリクエストを再試行します。成功すればクローズに戻り、失敗すればオープンに戻ります。

* **バルクヘッドパターン（Bulkhead Pattern）**:
    * **概要**: 障害を**隔離**し、その影響範囲を限定するためのパターンです。
    * **仕組み**: 船の防水隔壁（bulkhead）のように、アプリケーション内のリソース（スレッドプールなど）を分離し、あるサービスが失敗しても他のサービスに影響が及ばないようにします。これにより、部分的な障害が発生しても、アプリケーションの他の機能は正常に動作し続けます。

---

### 3. カオスエンジニアリング

* **概要**: 実際に本番環境で**意図的に障害を発生させ**、システムがどのように応答するかをテストする手法です。
* **目的**: 設計した耐障害性パターンが期待通りに機能するかを検証し、予期せぬ弱点を発見します。
* **事例**: Netflixの「カオスモンキー」は、本番環境のインスタンスをランダムに終了させ、システムの回復力を継続的にテストしています。これにより、「**本番環境で実際に失敗するまで、その応答はわからない**」という問題を解決します。