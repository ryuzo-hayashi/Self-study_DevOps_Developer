# The Kubernetes Ecosystem: OpenShift, Istio, etc.
## Red Hat OpenShift入門

### OpenShiftとは？

**Red Hat OpenShift**は、Red Hatが開発・サポートする**エンタープライズ向けのKubernetesコンテナプラットフォーム**です。
ハイブリッドクラウド戦略のために構築されており、一貫したアプリケーションプラットフォームを提供し、ハイブリッド、マルチクラウド、エッジ環境でのデプロイメントを管理します。

* **基盤**: Linux、コンテナ、自動化の技術を基盤としています。
* **目的**: 開発者がアイデアを開発から本番環境へ効率的に移行できるよう、フルスタックの自動化オペレーションとセルフサービスプロビジョニングを提供します。
* **特徴**: コンテナオーケストレーションだけでなく、アプリケーションのライフサイクル全体（ビルド、CI/CD、モニタリング、ログ）をサポートする追加ツールも提供します。
* **Kubernetesとの関係**: OpenShiftは**Kubernetesの拡張**であり、Kubernetesを基盤として、より堅牢で包括的なプラットフォームを提供します。

### OpenShiftの主な機能

* **スケーラビリティ**: アプリケーションを数百のノードにまたがる数千のインスタンスに数秒でスケールできます。
* **ハイブリッドインフラ**: 柔軟なハイブリッドインフラオプションにより、デプロイと管理が簡素化されます。
* **オープンスタンダード**: KubernetesとOCI（Open Container Initiative）コンテナを使用しており、開発者は慣れ親しんだ環境で作業でき、コンテナは複数の環境で移植可能です。
* **開発者ツール**: マルチ言語サポート、コマンドライン、IDE統合など、包括的な開発者ツールセットが含まれています。
* **自動化**: コンテナとアプリケーションのビルド、デプロイ、スケーリング、ヘルス管理が自動化されます。
* **セキュリティ**: アクセス制御、ネットワーキング、エンタープライズレジストリ、組み込みスキャナー、脅威検出、脆弱性管理、リスクプロファイリングなど、厳格なセキュリティポリシーを提供します。
* **ストレージ**: ステートフルおよびステートレスなアプリケーション実行のためのエンタープライズ向け永続ストレージソリューションをサポートします。

---

### OpenShiftとKubernetesの比較

| 項目 | OpenShift | Kubernetes |
| :--- | :--- | :--- |
| **位置づけ** | Red Hatが提供する**製品** | **オープンソースプロジェクト** |
| **インストール** | 非常に限定的なオプション | どのLinux環境にもインストール可能 |
| **柔軟性** | 柔軟性が低い | 柔軟性が高い |
| **提供環境** | Azure、専用環境で利用可能 | AWS (EKS), GCP (GKE), Azure (AKS) で利用可能 |
| **コンテナ管理** | **Image Stream**で管理が容易 | コンテナイメージ管理が比較的難しい |
| **セキュリティ** | 厳格なセキュリティポリシー | メンテナンスが容易 |
| **外部アクセス** | **Routerオブジェクト**を使用 | **Ingressオブジェクト**を使用 |
| **デプロイ** | **Deployment Config**を使用 (柔軟性が低い) | **Deploymentオブジェクト**を使用 (柔軟性が高い) |
| **ユーザー体験** | 優れたWebコンソール、初心者向け | より良いユーザー体験には追加ツールが必要 |
| **ネットワーキング**| アウトオブボックスで優れたソリューションを提供 | ネットワークソリューションがない場合はサードパーティプラグインが必要 |
| **CI/CD** | **Jenkinsと統合**されている | Jenkinsとの統合はされていない |

---

### OpenShiftのアーキテクチャとコンポーネント

OpenShiftはKubernetesクラスタの上に構築され、オブジェクトデータは**etcd**キーバリューストアに格納されます。マイクロサービスベースのアーキテクチャを持ちます。

* **マスターノード**: **Red Hat Enterprise Linux CoreOS**で動作。
* **ワーカーノード**: **Red Hat Enterprise Linux**をサポート。

#### CLI (コマンドラインインターフェース)

OpenShiftは、端末から管理や開発の操作を実行できるCLIツールセットを提供します。

* **`oc`**: OpenShift専用のCLIツール。Windows、Linux、Macで動作し、エンドツーエンドの操作を実行できます。**`kubectl`の機能を包含**しつつ、OpenShift独自の機能（デプロイメントコンフィグ、ビルドコンフィグ、ルートなど）をネイティブにサポートします。
* **`kubectl`**: `oc`には`kubectl`のバイナリも含まれています。基本的なKubernetesの操作は`kubectl`でも可能です。

---

### 用語解説

* **etcd**: Kubernetesクラスタのすべてのデータ（クラスタの状態、設定など）を保存する分散キーバリューストア。
* **Docker**: Linuxベースの軽量コンテナイメージをパッケージ化し、作成するための抽象化レイヤー。
* **Kubernetes**: 複数のホスト上でコンテナをオーケストレーション（自動化された配置、スケーリング、管理）するクラスタ管理ツール。
* **CI/CD**:
    * **CI (Continuous Integration)**: 継続的インテグレーション。コード変更を頻繁に共有リポジトリに統合し、自動的にビルドとテストを行うプロセス。
    * **CD (Continuous Delivery/Deployment)**: 継続的デリバリー/デプロイメント。CIプロセスの成功後、アプリケーションを本番環境に自動的にデプロイするプロセス。
* **Image Stream**: OpenShift独自の機能。コンテナイメージのバージョン管理と更新の自動化を容易にします。
* **Router**: OpenShiftで外部からのトラフィックをクラスタ内のサービスにルーティングするためのオブジェクト。Kubernetesの**Ingress**に相当します。

## OpenShiftにおけるビルドと自動化

### ビルドの基本

**ビルド**とは、ソースコードなどの入力を、コンテナイメージのような最終的なオブジェクトに変換するプロセスです。
このプロセスは**ビルド設定ファイル（Build Config）によって定義され、ビルドの戦略**と**入力ソース**を指定します。

**ビルド入力ソース**
複数の入力を組み合わせて使用でき、優先順位が高いものが低いものを上書きします。
優先順位は以下の通りです。

1.  インラインの`Dockerfile`定義
2.  既存イメージから抽出されたコンテンツ
3.  Gitリポジトリ
4.  バイナリまたはローカルの入力
5.  入力シークレット
6.  外部アーティファクト

### ビルド戦略

OpenShiftには、主に3つのビルド戦略があります。

1.  **Source-to-Image (S2I)**

      * **特徴**: ソースコードとビルダーイメージを組み合わせて、実行可能なコンテナイメージを**Dockerfileを使わずに**生成します。
      * **利点**: 開発の手間を省き、単一ステップでソースコードからイメージを作成できます。OpenShiftは様々なビルダーイメージを提供しています。

2.  **Docker**

      * **特徴**: Gitリポジトリにある**Dockerfile**と必要なアーティファクトを使用してビルドを行います。
      * **プロセス**: OpenShiftが入力（Gitリポジトリなど）を受け取り、`docker build`コマンドを実行してイメージを作成し、内部のOpenShiftレジストリにプッシュします。
      * **実装方法**: Dockerfileの置き換え、Dockerfileパスの指定、環境変数、ビルド引数の追加などがあります。

3.  **Custom（カスタム）**

      * **特徴**: ユーザーが独自の**ビルダーイメージ**を定義し、ビルドプロセスを完全に制御します。
      * **目的**: JARファイルやCI/CDデプロイメントの作成など、実行可能なコンテナイメージ以外のオブジェクトも生成できます。
      * **注意点**: 高い権限で実行されるため、クラスタ管理者のみが利用可能です。

-----

### イメージストリーム (Image Stream)

**イメージストリーム**は、OpenShift内でコンテナイメージを参照するための抽象化機能です。

  * **機能**: 実際のイメージデータは含まず、内部または外部のレジストリにあるイメージや、他のイメージストリームを指し示します。
  * **タグ付け**: 1つのイメージストリームには`latest`、`dev`、`test`といった複数のタグを含めることができ、各タグが特定のイメージを指します。
  * **利点**: デプロイ時にレジストリURLをハードコードする代わりにイメージストリームのタグを参照することで、元のイメージの場所が変更されても、イメージストリームの定義を更新するだけで済み、デプロイメントを個別に修正する必要がなくなります。また、新しいイメージバージョンが利用可能になった際に、自動的にビルドやデプロイを呼び出す**トリガー機能**も提供します。

-----

### ビルドの自動化（トリガー）

ビルドを手動で実行する代わりに、トリガーを使用してプロセスを自動化できます。

1.  **Webhookトリガー**:

      * GitHubなどの外部サービスからのリクエスト（新しいコミット、プルリクエストなど）をAPIエンドポイントで受け取り、ビルドを起動します。

2.  **イメージ変更トリガー**:

      * ベースイメージにセキュリティパッチや更新が適用され、新しいバージョンが利用可能になったときにビルドをトリガーします。

3.  **設定変更トリガー**:

      * 新しいビルド設定リソースが作成されたときに、新しいビルドを実行します。

-----

### ビルド設定ファイル（Build Config）の構成例

```yaml
apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: ruby-sample-build
spec:
  runPolicy: "Serial"
  triggers:
    - type: "ImageChange"
      imageChange: {}
    - type: "GitHub"
      github:
        secret: "..."
  source:
    type: "Git"
    git:
      uri: "https://github.com/openshift/ruby-ex.git"
  strategy:
    type: "Source"
    sourceStrategy:
      from:
        kind: "ImageStreamTag"
        name: "ruby-20-centos7:latest"
  output:
    to:
      kind: "ImageStreamTag"
      name: "ruby-sample-build:latest"
  postCommit:
    args: ["bundle", "exec", "rake", "test"]
    command: ["/bin/sh"]
```

  * `runPolicy`: ビルドの実行ポリシーを制御します。`Serial`（順番に）や`Simultaneously`（同時に）などが設定できます。
  * `triggers`: ビルドを起動するトリガーを指定します。
  * `source`: ビルドの入力ソース（例：Gitリポジトリ）を定義します。
  * `strategy`: 使用するビルド戦略（例：S2I）を定義します。
  * `output`: ビルドされたイメージの出力先（例：イメージストリームタグ）を指定します。
  * `postCommit`: ビルド後のフック（オプション）を定義します。

## オペレーター（Operator）

---

### オペレーターとは

**オペレーター**は、Kubernetesのカスタムコントローラーとして機能し、クラスターのタスクを自動化し、**Kubernetes APIを拡張**するソフトウェアです。人間のオペレーターの知識をソフトウェアに落とし込み、アプリケーションのデプロイ、管理、アップグレード、スケーリング、バックアップなどの反復的なタスクを自動化します。

* **役割**: アプリケーションの作成、設定、管理を自動化し、継続的かつリアルタイムな判断を行います。
* **特徴**:
    * Kubernetesネイティブのアプリケーションをパッケージ化、デプロイ、管理します。
    * 繰り返しの多いインストールやアップグレードプロセスを簡単にします。
    * 定期的にシステムのヘルスチェックを行います。
    * kubectlやOCコマンドなどのAPIやCLIツールと統合されます。
* **サービスブローカーとの比較**:
    * **オペレーター**: 長時間稼働するプロセスで、アップグレードやスケーリングといった日々の運用が可能です。クラスターの現在の状態を常に監視し、カスタマイズやパラメーター化を行います。
    * **サービスブローカー**: 短時間稼働するプロセスで、インストール時のみのカスタマイズやパラメーター化しかできず、日々の運用には向きません。

### カスタムリソース定義（CRD）とカスタムコントローラー

* **カスタムリソース定義（CRD）**:
    * Kubernetes APIに新しいオブジェクトを保存・取得するための仕組みです。
    * デプロイメントやPodのような組み込みリソースを超えて、**Kubernetesの機能を拡張**します。
    * クラスターごとにインストールされ、`kubectl`を使ってアクセスできます。
* **カスタムコントローラー**:
    * クラスターの**「実際の状態」**を**「設定された望ましい状態」**に一致させる（reconcile）役割を担います。
    * カスタムリソースに対しても同様の調整を行います。

この**CRDとカスタムコントローラーの組み合わせ**が、**オペレーターパターン**として知られており、新しい宣言型APIをKubernetes内に作成します。

---

### オペレーター関連のエコシステム

* **Operator Framework**:
    * オペレーターのコーディング、テスト、デリバリー、アップデートを包括的にサポートするオープンソースのツールセットです。
    * **Operator SDK**: オペレーターの作成者がKubernetes APIの複雑さを意識せずにオペレーターを構築、テスト、パッケージ化できるように支援します。**Helm、Go、Ansible**に対応しています。
    * **Operator Lifecycle Manager (OLM)**: クラスター内でのオペレーターのインストール、アップグレード、RBAC（ロールベースアクセス制御）を管理します。
    * **Operator Registry**: OLMにオペレーターのカタログデータを提供するために、CRD、CSV（Cluster Service Versions）、およびメタデータを保存します。

* **Operator Hub**:
    * クラスター管理者がインストールしたいオペレーターを探せるWebコンソールです。
    * **Red Hatオペレーター、認定オペレーター、コミュニティオペレーター、カスタムオペレーター**など、さまざまな種類のオペレーターが提供されています。

---

### Operator Maturity Model（オペレーター成熟度モデル）

オペレーターの管理ロジックの洗練度合いを示すモデルです。基本的なインストールから自律的な運用（オートパイロット）まで、オペレーターができることの範囲を定義します。

| 成熟度レベル | 説明                                                              |
| :----------- | :---------------------------------------------------------------- |
| **Level 1** | **Basic Install**（基本的なインストールと設定）                   |
| **Level 2** | **Seamless Upgrade**（シームレスなアップグレード）                |
| **Level 3** | **Full Lifecycle Management**（完全なライフサイクル管理）         |
| **Level 4** | **Deep Insights**（詳細な分析とメトリクス収集）                   |
| **Level 5** | **Autopilot**（障害対応や自己修復を含む完全な自律運用）           |

## Istio

---

### サービスメッシュとIstio

**サービスメッシュ**は、サービス間の通信を安全かつ信頼性の高いものにするための専用レイヤーです。トラフィック管理、セキュリティ、およびオブザーバビリティ（可観測性）を提供します。

**Istio**は、Kubernetes上でよく使用されるプラットフォームに依存しないサービスメッシュの実装です。Istioは以下の4つの概念をサポートします。

1.  **Connection (接続)**:
    * カナリアデプロイメントやA/Bテストなど、サービス間のトラフィックをインテリジェントに制御します。
    * ロードバランシング、ルーティング、連続リトライ、自動フェイルオーバーなどをサポートします。
2.  **Security (セキュリティ)**:
    * サービス間の通信を認証、認可、および暗号化によって保護します。
    * サービスアクセスコントロールのポリシーを簡単に実装できます。
3.  **Enforcement (強制)**:
    * アクセス制御、レート制限、クォータなどのポリシーをクラスター全体にわたって強制します。
4.  **Observability (可観測性)**:
    * メッシュ内のトラフィックフローを可視化し、コールフローや依存関係をトレースし、レイテンシやエラーなどのメトリクスを収集します。

---

### Istioのアーキテクチャ

Istioは主に以下の2つのコンポーネントで構成されます。

1.  **データプレーン (Data Plane)**:
    * サービス間の通信を処理します。
    * すべてのネットワークトラフィックを**Envoyプロキシ**によって傍受し、構成に応じて多くの機能を提供します。
2.  **コントロールプレーン (Control Plane)**:
    * 望ましい設定とサービスのビューを取得し、環境の変化に応じてEnvoyプロキシを動的にプログラムし更新します。

---

### マイクロサービスにおけるIstioの役割

マイクロサービスは、独立してデプロイ可能な小さなコンポーネントで構成されるアーキテクチャです。マイクロサービスは多くの利点を持つ一方で、以下の課題があります。

* **課題**:
    * 安全な通信を確保するための**トラフィック暗号化**。
    * 段階的な機能リリースや比較のための**カナリアデプロイメント**や**A/Bテスト**。
    * 単一サービスの不具合が他のサービスに波及する**カスケード障害**。

Istioはこれらの課題を解決するための機能を提供します。

* **トラフィックシフティングとA/Bテスト**: トラフィックを段階的に新しいバージョンに移行したり、特定のユーザーに特定のバージョンをルーティングしたりすることで、安全なデプロイメントを可能にします。
* **セキュリティ**: サービス間の通信を暗号化し、中間者攻撃から防御します。また、サービス間のアクセス制御ポリシーを実装し、不要な通信をブロックします。
* **オブザーバビリティ**: サービス通信のメトリクス（**レイテンシ、トラフィック、エラー、飽和度**）を自動的に収集・監視し、ボトルネックの特定やパフォーマンスの最適化に役立ちます。

---

### サービス監視の4つの基本メトリクス

Istioが提供するサービス通信メトリクスは、以下の4つの基本的な監視ニーズをカバーします。

| メトリクス | 説明                                                              |
| :--------- | :---------------------------------------------------------------- |
| **Latency** | リクエストの応答時間。パフォーマンスのボトルネックを特定します。    |
| **Traffic** | 処理されたリクエスト数。サービスの使用状況を把握します。              |
| **Errors** | 失敗したリクエストの数。サービスの健全性を測定します。              |
| **Saturation** | リソースの利用率。容量計画とスケーリングの判断材料となります。       |

## OpenShiftのビルドトリガーによるビルドの自動化

---

### ビルドトリガーとは
**ビルドトリガー**は、特定のイベントや条件に基づいて**OpenShiftのビルドプロセスを自動的に開始**する仕組みです。これにより、アプリケーションのアップデートやデプロイが自動化され、開発サイクルが短縮されます。

---

### ビルドトリガーの種類

OpenShiftには、主に以下の3つのビルドトリガーがあります。

1.  **Webhookトリガー**:
    * **仕組み**: 外部システム（例：GitHub）からの**HTTP POSTリクエスト**をトリガーとしてビルドを開始します。
    * **用途**: Gitリポジトリへのコミットやプルリクエストのマージといったイベントに連動して、最新のコードでビルドを自動的に実行する。
    * **特徴**:
        * GitHub, GitLab, Bitbucketなどの人気のあるGitリポジトリと連携可能。
        * イベント駆動型で、コミットやマージなどの様々なイベントに対応。
        * GenericとGitHub固有のWebhookの両方をサポートし、柔軟性が高い。
        

2.  **イメージ変更トリガー (Image Change Triggers)**:
    * **仕組み**: 指定されたコンテナイメージの新しいバージョンが利用可能になったことを検知して、ビルドを開始します。
    * **用途**: ベースイメージ（例：Node.js）のアップデートやセキュリティパッチが適用された際に、自動的にアプリケーションを再ビルドする。
    * **特徴**:
        * 依存関係の自動管理を可能にし、アプリケーションを常に最新の状態に保つ。
        * セキュリティ脆弱性への迅速な対応を支援する。
        

3.  **設定変更トリガー (Configuration Change Triggers)**:
    * **仕組み**: **BuildConfigリソース**が新規作成または変更されたときにビルドを開始します。
    * **用途**: ビルド設定（例：ソースリポジトリのURL、ビルド戦略）の変更を即座にアプリケーションに反映させる。
    * **特徴**:
        * 手動での操作なしに、ビルド設定の変更を自動的に適用する。
        * ビルド設定の管理を簡素化し、効率を向上させる。
        

---

### まとめ
これらのビルドトリガーは、それぞれ異なるシナリオに対応し、OpenShiftにおけるビルドとデプロイのプロセスを大幅に効率化します。Webhookトリガーはコードの変更に、イメージ変更トリガーは依存関係の更新に、そして設定変更トリガーはビルド設定自体の変更に自動的に対応することで、開発ワークフローを合理化し、手動での介入を減らします。

